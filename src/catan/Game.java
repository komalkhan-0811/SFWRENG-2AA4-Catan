// --------------------------------------------------------
// Code generated by Papyrus Java
// --------------------------------------------------------

package catan;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.nio.file.Path;
import java.nio.file.Paths;

/**
 * Main game controller for the Catan simulation
 * 
 * @author komal khan
 */
public class Game {
	
    private Board board;
    private List<Player> players;
    private Rules rules;
    private Dice dice;
    private java.util.Random rng;
    private int roundNumber;
    private int maxRounds;
    private int victoryPointsToWin;

    
    private Path stateOutputDir = Paths.get("."); // default: current folder
    public void setStateOutputDir(Path dir) {
        this.stateOutputDir = dir;
    }

    /**
     * Constructor for Game
     * @param maxRounds maximum number of rounds to play
     */
    public Game(int maxRounds) {
        this.maxRounds = maxRounds;
        this.rng = new java.util.Random();
        this.dice = new Dice(rng);
        this.victoryPointsToWin = 10;
    }

    /**
     * R1.1: Set up a valid map with specified identification
     * R1.2: Initialize 4 randomly acting agents
     */
    public void initializeNewGame() {
        board = new Board();
        board.initializeFixedMapLayout();

        rules = new Rules();

     
        players = new ArrayList<>();
        players.add(new Player(1, Colour.RED));
        players.add(new Player(2, Colour.BLUE));
        players.add(new Player(3, Colour.GREEN));
        players.add(new Player(4, Colour.YELLOW));

        roundNumber = 1;
        Login.printGameStart(maxRounds);
        
        // Initial placement phase (Catan rules)
        initialPlacementPhase();
    }

    /**
     * Initial placement phase following Catan rules:
     * Each player places 1 settlement + 1 road (order: 1,2,3,4)
     * Each player places 1 settlement + 1 road (reverse: 4,3,2,1)
     * Second settlement placement gives resources from adjacent tiles
     */
    private void initialPlacementPhase() {
        System.out.println("=== Initial Placement Phase ===");
        
        // First round of placements (players 1,2,3,4)
        for (int i = 0; i < players.size(); i++) {
            placeInitialSettlementAndRoad(players.get(i), false);
        }
        
        // Second round of placements (players 4,3,2,1) - reverse order
        for (int i = players.size() - 1; i >= 0; i--) {
            placeInitialSettlementAndRoad(players.get(i), true);
        }
        
        System.out.println();
    }

    /**
     * Place one settlement and one road for a player during initial setup
     * @param player The player placing
     * @param giveResources If true, player receives resources from adjacent tiles
     */
    private void placeInitialSettlementAndRoad(Player player, boolean giveResources) {
        // Find valid settlement locations
        List<Integer> validSettlements = new ArrayList<>();
        for (int id : board.getAllIntersectionIds()) {
            if (rules.canBuildSettlement(player, board, id)) {
                validSettlements.add(id);
            }
        }
        
        if (validSettlements.isEmpty()) {
            System.out.println("Player " + player.getPlayerId() + ": No valid settlement locations!");
            return;
        }
        
        // Randomly choose a settlement location
        int settlementId = validSettlements.get(rng.nextInt(validSettlements.size()));
        
        // Place settlement
        board.placeSettlement(player.getPlayerId(), settlementId);
        player.recordPlacedSettlement(settlementId);
        player.addVictoryPoints(Building.SETTLEMENT.getVictoryPoints());
        
        System.out.println("Player " + player.getPlayerId() + ": Placed initial settlement at intersection " + settlementId);
        
        // Give resources if this is the second settlement
        if (giveResources) {
            giveInitialResources(player, settlementId);
        }
        
        // Find valid road locations connected to this settlement
        List<Edge> validRoads = new ArrayList<>();
        for (Edge edge : board.getAllEdges()) {
            if (edge.touchesIntersection(settlementId) && !edge.isOccupied()) {
                validRoads.add(edge);
            }
        }
        
        if (!validRoads.isEmpty()) {
            // Randomly choose a road location
            Edge roadEdge = validRoads.get(rng.nextInt(validRoads.size()));
            
            // Place road
            board.placeRoad(player.getPlayerId(), roadEdge.getIntersectionA(), roadEdge.getIntersectionB());
            player.recordPlacedRoad(roadEdge.getIntersectionA(), roadEdge.getIntersectionB());
            
            System.out.println("Player " + player.getPlayerId() + ": Placed initial road between " + 
                roadEdge.getIntersectionA() + " and " + roadEdge.getIntersectionB());
        }
    }

    /**
     * Give player resources from tiles adjacent to their settlement (initial placement)
     * @param player The player receiving resources
     * @param intersectionId The settlement location
     */
    private void giveInitialResources(Player player, int intersectionId) {
        int[] adjacentTileIds = board.getAdjacentTileIds(intersectionId);
        
        for (int tileId : adjacentTileIds) {
            Tile tile = board.getTile(tileId);
            if (tile != null && tile.getResource() != Resources.DESERT) {
                player.addResource(tile.getResource(), 1);
            }
        }
    }

    /**
     *  Run simulation until termination condition
     */
    public void runSimulationUntilTermination() {
        while (!isTerminationReached()) {
            playOneRound();
            printRoundScoreboard();

            // Write JSON state at end of each round
            try{
                GameStateWriter.writeBasicRoundState(this, stateOutputDir);
            }
            catch (Exception e) {
                System.out.println("Failed to write game state: " + e.getMessage());
            }
            roundNumber++;
        }

        Player winner = getWinnerOrNull();
        Login.printGameOver(winner, roundNumber);
    }

    /**
     * Play one complete round (all 4 players take turns)
     */
    public void playOneRound() {
        for (Player p : players) {
            playOneTurn(p);
            if (isTerminationReached()) {
                break;
            }
        }
    }

    /**
     * Execute one player's turn
     * Output format [RoundNumber] / [PlayerID]: [Action]
     * Agents with >7 cards must try to spend
     * @param player the player taking their turn
     */
    public void playOneTurn(Player player) {
        int roll = rollDice();
        
   
        if (roll != 7) {
            distributeResourcesForRoll(roll);
        }

        // R1.8: If player has more than 7 cards, they MUST try to build
        boolean mustBuild = player.getTotalCardsInHand() > 7;
        
        List<Action> validActions = rules.getValidActionsByLinearScan(player, board);
        
        // R1.8: Filter out PASS if player has > 7 cards
        if (mustBuild) {
            List<Action> buildActions = new ArrayList<>();
            for (Action action : validActions) {
                if (action.getType() != ActionType.PASS) {
                    buildActions.add(action);
                }
            }
 
            if (!buildActions.isEmpty()) {
                validActions = buildActions;
            }
        }
        
        Action chosen = rules.chooseRandomAction(validActions, rng);

        if (chosen != null && chosen.getType() != ActionType.PASS) {
            Map<Resources, Integer> cost = rules.getCost(chosen.getType());
            if (player.hasEnoughResources(cost)) {
                player.payCost(cost);
                executeAction(player, chosen);
                Login.printTurnAction(roundNumber, player.getPlayerId(), chosen.describeForLogin());
            } else {
                // Can't afford chosen action
                Login.printTurnAction(roundNumber, player.getPlayerId(), "Passed");
            }
        } else {
            // PASS action
            Login.printTurnAction(roundNumber, player.getPlayerId(), "Passed");
        }
    }

    /**
     * Roll two six-sided dice
     */
    public int rollDice() {
        return dice.rollTwoSixSidedDice();
    }

    /**
     * Distribute resources based on dice roll
     * Handles robber: rolling 7 produces no resources
     * @param roll the dice roll value
     */
    public void distributeResourcesForRoll(int roll) {
        List<Tile> producingTiles = board.getTilesProducingOnRoll(roll);
        
        for (Tile tile : producingTiles) {
            Resources resource = tile.getResource();
            List<Integer> adjacentIntersections = board.getIntersectionsAdjacentToTile(tile.getTileId());
            
            for (int intersectionId : adjacentIntersections) {
                Intersection intersection = board.getIntersection(intersectionId);
                
                if (intersection != null && intersection.hasBuilding()) {
                    Integer ownerId = intersection.getBuildingOwnerId();
                    Building buildingType = intersection.getBuildingType();
                    
                    if (ownerId != null) {
                        Player owner = getPlayerById(ownerId);
                        if (owner != null) {
                            // Settlements = 1 resource, Cities = 2 resources
                            int amount = (buildingType == Building.CITY) ? 2 : 1;
                            owner.addResource(resource, amount);
                        }
                    }
                }
            }
        }
    }

    private Player getPlayerById(int playerId) {
        for (Player p : players) {
            if (p.getPlayerId() == playerId) {
                return p;
            }
        }
        return null;
    }

    /**
     * Check termination conditions
     * More than maxRounds rounds played
     * Any player has 10+ victory points
     */
    public boolean isTerminationReached() {
        if (roundNumber > maxRounds) {
            return true;
        }

        for (Player p : players) {
            if (p.getVictoryPoints() >= victoryPointsToWin) {
                return true;
            }
        }
        return false;
    }

    /**
     *
     * Roads must be connected to player network
     * Cities must replace settlements
     * Distance rule enforced
     */
    private void executeAction(Player player, Action action) {
        switch (action.getType()) {
            case BUILD_ROAD:
                board.placeRoad(
                    player.getPlayerId(),
                    action.getEdgeIntersectionA(),
                    action.getEdgeIntersectionB());
                player.recordPlacedRoad(
                    action.getEdgeIntersectionA(),
                    action.getEdgeIntersectionB());
                break;

            case BUILD_SETTLEMENT:
                board.placeSettlement(
                    player.getPlayerId(),
                    action.getIntersectionId());
                player.recordPlacedSettlement(action.getIntersectionId());
                player.addVictoryPoints(Building.SETTLEMENT.getVictoryPoints());
                break;

            case BUILD_CITY:
                board.upgradeSettlementToCity(
                    player.getPlayerId(),
                    action.getIntersectionId());
                player.recordUpgradedCity(action.getIntersectionId());
                player.addVictoryPoints(1); // +1 additional VP
                break;

            case PASS:
                break;
        }
    }

    public Player getWinnerOrNull() {
        for (Player p : players) {
            if (p.getVictoryPoints() >= victoryPointsToWin) {
                return p;
            }
        }
        return null;
    }

    /**
     * Print victory points at end of each round
     */
    public void printRoundScoreboard() {
        System.out.println("-----Round " + roundNumber + " ----");
        for (Player p : players) {
            System.out.println("Player " + p.getPlayerId() + " VP: " + p.getVictoryPoints());
        }
    }
}