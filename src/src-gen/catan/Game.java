 // --------------------------------------------------------
// Code generated by Papyrus Java
// --------------------------------------------------------

package catan;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

/**
 * Main game controller for the Catan simulation
 */
public class Game {
    /**
     *
     */
    private Board board;
    /**
     *
     */
    private List<Player> players;
    /**
     *
     */
    private Rules rules;
    /**
     *
     */
    private Dice dice;
    /**
     *
     */
    private java.util.Random rng;
    /**
     *
     */
    private int roundNumber;
    /**
     *
     */
    private int maxRounds;
    /**
     *
     */
    private int victoryPointsToWin;

    /**
     * Constructor for Game
     * @param maxRounds maximum number of rounds to play
     */
    public Game(int maxRounds) {
        this.maxRounds = maxRounds;
        this.rng = new java.util.Random();
        this.dice = new Dice(rng);
        this.victoryPointsToWin = 10; // Standard Catan victory condition
    }

    /**
     * Initialize a new game with board, rules, and players
     */
    public void initializeNewGame() {
        board = new Board();
        board.initializeFixedMapLayout();

        rules = new Rules();

        players = new ArrayList<>();
        players.add(new Player(1, Colour.RED));
        players.add(new Player(2, Colour.BLUE));
        players.add(new Player(3, Colour.GREEN));
        players.add(new Player(4, Colour.YELLOW));

        roundNumber = 1;

        Login.printGameStart(maxRounds);
    }

    /**
     * Run the simulation until a termination condition is met
     */
    public void runSimulationUntilTermination() {
        while (!isTerminationReached()) {
            playOneRound();
            printRoundScoreboard();
            roundNumber++;
        }

        Player winner = getWinnerOrNull();
        Login.printGameOver(winner, roundNumber);
    }

    /**
     * Play one complete round (all players take turns)
     */
    public void playOneRound() {
        for (Player p : players) {
            playOneTurn(p);
            if (isTerminationReached()) {
                break;
            }
        }
    }

    /**
     * Execute one player's turn
     * @param player the player taking their turn
     */
    public void playOneTurn(Player player) {
        int roll = rollDice();
        distributeResourcesForRoll(roll);

        List<Action> validActions = rules.getValidActionsByLinearScan(player, board);
        Action chosen = rules.chooseRandomAction(validActions, rng);

        if (chosen != null && chosen.getType() != ActionType.PASS) {
            // Check if player can afford the action
            Map<Resources, Integer> cost = rules.getCost(chosen.getType());
            if (player.hasEnoughResources(cost)) {
                player.payCost(cost);
                executeAction(player, chosen);
                Login.printTurnAction(roundNumber, player.getPlayerId(), chosen.describeForLogin());
            }
        }
    }

    /**
     * Roll the dice
     * @return the sum of two six-sided dice
     */
    public int rollDice() {
        return dice.rollTwoSixSidedDice();
    }

    /**
     * Distribute resources to players based on the dice roll
     * @param roll the dice roll value
     */
    public void distributeResourcesForRoll(int roll) {
        // Get all tiles that produce on this roll
        List<Tile> producingTiles = board.getTilesProducingOnRoll(roll);
        
        for (Tile tile : producingTiles) {
            Resources resource = tile.getResource();
            
            // Get all intersections adjacent to this tile
            List<Integer> adjacentIntersections = board.getIntersectionsAdjacentToTile(tile.getTileId());
            
            for (int intersectionId : adjacentIntersections) {
                Intersection intersection = board.getIntersection(intersectionId);
                
                if (intersection != null && intersection.hasBuilding()) {
                    Integer ownerId = intersection.getBuildingOwnerId();
                    Building buildingType = intersection.getBuildingType();
                    
                    if (ownerId != null) {
                        Player owner = getPlayerById(ownerId);
                        if (owner != null) {
                            // Settlements produce 1 resource, cities produce 2
                            int amount = (buildingType == Building.CITY) ? 2 : 1;
                            owner.addResource(resource, amount);
                        }
                    }
                }
            }
        }
    }

    /**
     * Get a player by their ID
     * @param playerId the player's ID
     * @return the Player object or null if not found
     */
    private Player getPlayerById(int playerId) {
        for (Player p : players) {
            if (p.getPlayerId() == playerId) {
                return p;
            }
        }
        return null;
    }

    /**
     * Check if the game should terminate
     * @return true if termination condition is met
     */
    public boolean isTerminationReached() {
        if (roundNumber > maxRounds) {
            return true;
        }

        for (Player p : players) {
            if (p.getVictoryPoints() >= victoryPointsToWin) {
                return true;
            }
        }
        return false;
    }

    /**
     * Execute an action for a player
     * @param player the player performing the action
     * @param action the action to execute
     */
    private void executeAction(Player player, Action action) {
        switch (action.getType()) {
            case BUILD_ROAD:
                board.placeRoad(
                    player.getPlayerId(),
                    action.getEdgeIntersectionA(),
                    action.getEdgeIntersectionB());

                player.recordPlacedRoad(
                    action.getEdgeIntersectionA(),
                    action.getEdgeIntersectionB());
                break;

            case BUILD_SETTLEMENT:
                board.placeSettlement(
                    player.getPlayerId(),
                    action.getIntersectionId());

                player.recordPlacedSettlement(action.getIntersectionId());
                player.addVictoryPoints(Building.SETTLEMENT.getVictoryPoints());
                break;

            case BUILD_CITY:
                board.upgradeSettlementToCity(
                    player.getPlayerId(),
                    action.getIntersectionId());

                player.recordUpgradedCity(action.getIntersectionId());
                // Cities give 1 additional VP (settlement already gave 1)
                player.addVictoryPoints(1);
                break;

            case PASS:
                break;
        }
    }

    /**
     * Get the winning player, if any
     * @return the Player who won, or null if no winner yet
     */
    public Player getWinnerOrNull() {
        for (Player p : players) {
            if (p.getVictoryPoints() >= victoryPointsToWin) {
                return p;
            }
        }
        return null;
    }

    /**
     * Print the current scoreboard
     */
    public void printRoundScoreboard() {
        System.out.println("-----Round " + roundNumber + " ----");

        for (Player p : players) {
            System.out.println("Player " + p.getPlayerId() + " VP: " + p.getVictoryPoints());
        }
    }
}